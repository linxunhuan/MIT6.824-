# 分布式系统的驱动力和挑战
+ 分布式系统的核心是通过网络来协调，共同完成一致任务的一些计算机
+ 本课程中将会重点介绍一些案例，包括：
  + 大型网站的储存系统、大数据运算
    + 如 MapReduce、以及一些更为奇妙的技术
    + 比如点对点的文件共享
+ 分布式计算重要的原因是:
  + 许多重要的基础设施都是在它之上建立的，它们需要多台计算机或者说本质上需要多台物理隔离的计算机
+ 人们使用大量的相互协作的计算机驱动力是：
  + 人们需要获得更高的计算性能
    + 可以这么理解这一点，（大量的计算机意味着）大量的并行运算，大量CPU、大量内存、以及大量磁盘在并行的运行
  + 另一个人们构建分布式系统的原因是，它可以提供容错（tolerate faults）
    + 比如两台计算机运行完全相同的任务，其中一台发生故障，可以切换到另一台
  + 第三个原因是，一些问题天然在空间上是分布的
    + 例如银行转账，我们假设银行A在纽约有一台服务器，银行B在伦敦有一台服务器
    + 这就需要一种两者之间协调的方法
    + 所以，有一些天然的原因导致系统是物理分布的
  + 最后一个原因是，人们构建分布式系统来达成一些安全的目标
    + 比如有一些代码并不被信任，但是你又需要和它进行交互，这些代码不会立即表现的恶意或者出现bug
    + 你不会想要信任这些代码，所以你或许想要将代码分散在多处运行
    + 这样你的代码在另一台计算机运行，我的代码在我的计算机上运行，我们通过一些特定的网络协议通信
    + 所以，我们可能会担心安全问题，我们把系统分成多个的计算机，这样可以限制出错域
-------------------------------------------
+ 这门课程中，我们主要会讨论前两点：性能和容错
  + 所有的这些分布式系统的问题（挑战）在于：
    + 因为系统中存在很多部分，这些部分又在并发执行
      + 你会遇到并发编程和各种复杂交互所带来的问题，以及时间依赖的问题（比如同步，异步）
      + 这让分布式系统变得很难
    + 另一个导致分布式系统很难的原因是
      + 分布式系统有多个组成部分，再加上计算机网络，你会会遇到一些意想不到的故障
      + 如果你只有一台计算机，那么它通常要么是工作，要么是故障或者没电
      + 而由多台计算机组成的分布式系统，可能会有一部分组件在工作，而另一部分组件停止运行
      + 或者这些计算机都在正常运行，但是网络中断了或者不稳定
      + 所以，局部错误也是分布式系统很难的原因
    + 最后一个导致分布式系统很难的原因是
      + 人们设计分布式系统的根本原因通常是为了获得更高的性能
      + 比如说一千台计算机或者一千个磁盘臂达到的性能
      + 但是实际上一千台机器到底有多少性能是一个棘手的问题，这里有很多难点
      + 所以通常需要倍加小心地设计才能让系统实际达到你期望的性能
# 分布式系统的抽象和实现工具
+ 人们在构建分布系统时，使用了很多的工具，例如：
  + RPC（Remote Procedure Call）
    + RPC的目标就是掩盖我们正在不可靠网络上通信的事实
  + 线程
    + 线程提供了一种结构化的并发操作方式，这样，从程序员角度来说可以简化并发操作
  + 锁
    + 有了线程肯定有锁，这个学了操作系统都知道
# 可扩展性（Scalability）
如果一台计算机解决了一些问题，当用第二台计算机，只需要一半的时间就可以解决这些问题，或者说每分钟可以解决两倍数量的问题
两台计算机构成的系统如果有两倍性能或者吞吐，就是可扩展性
# 可用性（Availability）
+ 因为错误总会发生，必须要在设计时就考虑，系统能够屏蔽错误，或者说能够在出错时继续运行
+ 如果出现了问题，服务会停止工作，不再响应请求，之后有人来修复，并且在修复之后系统仍然可以正常运行，就像没有出现过问题一样
  + 例如将最新的数据存放在磁盘中，这样在供电恢复之后（假设故障就是断电），才能将这些数据取回来
+ 为了实现这些特性，有很多工具。其中最重要的有两个：
  + 非易失存储（non-volatile storage，类似于硬盘）
    + 这样当出现类似电源故障，甚至整个机房的电源都故障时，我们可以使用非易失存储
      + 比如硬盘，闪存，SSD之类的
      + 我们可以存放一些checkpoint或者系统状态的log在这些存储中
      + 这样当备用电源恢复或者某人修好了电力供给，我们还是可以从硬盘中读出系统最新的状态，并从那个状态继续运行
    + 因为更新非易失存储是代价很高的操作，所以相应的出现了很多非易失存储的管理工具
      + 同时构建一个高性能，容错的系统，聪明的做法是避免频繁的写入非易失存储
      + 在过去，甚至对于今天的一个3GHZ的处理器，写入一个非易失存储意味着移动磁盘臂并等待磁碟旋转，这两个过程都非常缓慢
      + 有了闪存会好很多，但是为了获取好的性能，仍然需要许多思考
  + 复制（replication）
    + 管理复制的多副本系统会有些棘手
    + 任何一个多副本系统中，都会有一个关键的问题
      + 比如说，我们有两台服务器，它们本来应该是有着相同的系统状态
      + 现在的关键问题在于，这两个副本总是会意外的偏离同步的状态，而不再互为副本
    + 对于任何一种使用复制实现容错的系统，我们都面临这个问题
#  一致性（Consistency）
+ 假设我们在构建一个分布式存储系统，并且这是一个KV服务
  + 这个KV服务只支持两种操作
    + 其中一个是put操作会将一个value存入一个key
    + 另一个是get操作会取出key对应的value
  + 整体表现就像是一个大的key-value表单
+ 一致性就是用来定义操作行为的概念
  + 从性能和容错的角度来说，我们通常会有多个副本
  + 在一个非分布式系统中，你通常只有一个服务器，一个表单
    + put就是更新这个表单
    + get就是从表单中获取当前表单中存储的数据
  + 但是在一个分布式系统中，由于复制或者缓存，数据可能存在于多个副本当中
    + 于是就有了多个不同版本的key-value对
  + 假设服务器有两个副本，那么他们都有一个key-value表单，两个表单中key 1对应的值都是20
    + 现在某个客户端发送了一个put请求，并希望将key 1改成值21
      + 这个put请求发送给了第一台服务器
      + 之后会发送给第二台服务器，因为相同的put请求需要发送给两个副本，这样这两个副本才能保持同步
    + 但是就在客户端准备给第二台服务器发送相同请求时，这个客户端故障了
      + 可能是电源故障或者操作系统的bug之类的
      + 所以，现在我们处于一个不好的状态，我们发送了一个put请求，更新了一个副本的值是21，但是另一个副本的值仍然是20
## 强一致性和弱一致性
+ get请求可以得到最近一次完成的put请求写入的值
  + 这种一般也被称为强一致（Strong Consistency）
+ 弱一致是指
  + 不保证get请求可以得到最近一次完成的put请求写入的值
  + 所以在一个弱一致系统中，某人通过put请求写入了一个数据，但是你通过get看到的可能仍然是一个旧数据，而这个旧数据可能是很久之前写入的
+ 虽然强一致可以确保get获取的是最新的数据，但是实现这一点的代价非常高
  + 分布式系统的各个组件需要做大量的通信，才能实现强一致性
  + 如果你有多个副本，那么不管get还是put都需要询问每一个副本
    + 在之前的例子中，客户端在更新的过程中故障了，导致一个副本更新了，而另一个副本没有更新
    + 如果我们要实现强一致，简单的方法就是同时读两个副本，如果有多个副本就读取所有的副本，并使用最近一次写入的数据
    + 所以，为了尽可能的避免通信，尤其当副本相隔的很远的时候，人们会构建弱一致系统，并允许读取出旧的数据
# MapReduce基本工作方式
+ MapReduce是由Google设计，开发和使用的一个系统
+ Google当时面临的问题是，他们需要在TB级别的数据上进行大量的计算
  + 比如说，为所有的网页创建索引，分析整个互联网的链接路径并得出最重要或者最权威的网页
  + 构建索引基本上等同于对整个数据做排序，而排序比较费时
  + 当时Google非常希望能将对大量数据的大量运算并行跑在几千台计算机上，这样才能快速完成计算
+ Google需要一种框架，可以让它的工程师能够进行任意的数据分析
  + 例如排序，网络索引器，链接分析器以及任何的运算
  + 工程师只需要实现应用程序的核心，就能将应用程序运行在数千台计算机上，而不用考虑：
    + 如何将运算工作分发到数千台计算机
    + 如何组织这些计算机
    + 如何移动数据
    + 如何处理故障等等这些细节
  + 也就是，当时Google需要一种框架，使得普通工程师也可以很容易的完成并运行大规模的分布式运算
----------------------------------------
+ MapReduce的思想是
  + 应用程序设计人员和分布式运算的使用者，只需要写简单的Map函数和Reduce函数
  + 而不需要知道任何有关分布式的事情，MapReduce框架会处理剩下的事情
+ 抽象来看，MapReduce假设有一些输入，这些输入被分割成大量的不同的文件或者数据块
+ 所以，我们假设现在有输入文件1，输入文件2和输入文件3
  + 这些输入可能是从网上抓取的网页，更可能是包含了大量网页的文件
  + MapReduce启动时，会查找Map函数
    + 之后，MapReduce框架会为每个输入文件运行Map函数
    + 这里很明显有一些可以并行运算的地方，比如说可以并行运行多个只关注输入和输出的Map函数
+ Map函数以文件作为输入，文件又是整个输入数据的一部分
  + Map函数的输出是一个key-value对的列表
  + 假设我们在实现一个最简单的MapReduce Job：单词计数器。它会统计每个单词出现的次数
    + Map函数会将输入中的每个单词拆分，并输出一个key-value对，key是该单词，value是1
    + 最后需要对所有的key-value进行计数，以获得最终的输出
      + 假设输入文件1包含了单词a和单词b，Map函数的输出将会是key=a，value=1和key=b，value=1
      + 第二个Map函数只从输入文件2看到了b，那么输出将会是key=b，value=1
      + 第三个输入文件有一个a和一个c
    + 对所有的输入文件都运行了Map函数，并得到了论文中称之为中间输出（intermediate output）
      + 也就是每个Map函数输出的key-value对
    + 运算的第二阶段是运行Reduce函数
      + MapReduce框架会收集所有Map函数输出的每一个单词的统计
      + 比如说，MapReduce框架会先收集每一个Map函数输出的key为a的key-value对
      + 收集了之后，会将它们提交给Reduce函数
    + 之后会收集所有的b
      + 这里的收集是真正意义上的收集
      + 因为b是由不同计算机上的不同Map函数生成，所以不仅仅是数据从一台计算机移动到另一台
      + （如果Map只在一台计算机的一个实例里，可以直接通过一个RPC将数据从Map移到Reduce）
      + 我们收集所有的b，并将它们提交给另一个Reduce函数
      + 这个Reduce函数的入参是所有的key为b的key-value对
      + 所以，MapReduce框架会为所有Map函数输出的每一个key，调用一次Reduce函数
    + 在这个简单的单词计数器的例子中
      + Reduce函数只需要统计传入参数的长度，甚至都不用查看传入参数的具体内容
      + 因为每一个传入参数代表对单词加1，而我们只需要统计个数
      + 最后，每个Reduce都输出与其关联的单词和这个单词的数量
      + 所以第一个Reduce输出a=2，第二个Reduce输出b=2，第三个Reduce输出c=1
+ 从整体来看，为了保证完整性，有一些术语要介绍一下：
  + Job。整个MapReduce计算称为Job
  + Task。每一次MapReduce调用称为Task
+ 所以，对于一个完整的MapReduce Job，它由一些Map Task和一些Reduce Task组成
# Map函数和Reduce函数
+ Map函数使用一个key和一个value作为参数
  + key是输入文件的名字
    + 通常会被忽略，因为我们不太关心文件名是什么
  + value是输入文件的内容
    + 所以，对于一个单词计数器来说，value包含了要统计的文本，我们会将这个文本拆分成单词
    + 之后对于每一个单词，我们都会调用emit
  + emit由MapReduce框架提供，并且这里的emit属于Map函数
    + emit会接收两个参数，其中一个是key，另一个是value
    + 在单词计数器的例子中，emit入参的key是单词，value是字符串“1”
--------------------------------------------
+ Reduce函数的入参是某个特定key的所有实例
  + （Map输出中的key-value对中，出现了一次特定的key就可以算作一个实例）
+ 所以Reduce函数也是使用一个key和一个value作为参数
  + 其中value是一个数组，里面每一个元素是Map函数输出的key的一个实例的value
+ 对于单词计数器来说
  + key就是单词，value就是由字符串“1”组成的数组
  + 我们不需要关心value的内容是什么，我们只需要关心value数组的长度
  + Reduce函数也有一个属于自己的emit函数
    + 这里的emit函数只会接受一个参数value
    + 这个value会作为Reduce函数入参的key的最终输出
  + 所以，对于单词计数器，我们会给emit传入数组的长度

