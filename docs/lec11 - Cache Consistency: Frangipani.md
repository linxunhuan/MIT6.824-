# Frangipani 初探
+ Frangipani论文里面有大量缓存一致性的介绍（Cache Coherence）
  + 缓存一致性是指:
    + 如果缓存了一些数据，之后你修改了实际数据但是并没有考虑缓存中的数据
    + 必须有一些额外的工作的存在，这样缓存才能与实际数据保持一致
+ 论文还介绍了分布式事务（Distributed Transaction）
  + 这对于向文件系统的数据结构执行复杂更新来说是必须的
  + 因为文件本质上是分割散落在大量的服务器上，能够从这些服务器实现分布式故障恢复（Distributed Crash Recovery）也是至关重要的
+ 从整体架构上来说，Frangipani就是一个网络文件系统（NFS，Network File System）
  + 它的目标是与已有的应用程序一起工作，比如说一个运行在工作站上的普通UNIX程序
  + 它与Athena的AFS非常类似（没听过）
  + 从一个全局视图来看，它包含了大量的用户（U1，U2，U3）
<img src=".\picture\image119.png">

+ 三个用户对应的工作站（Workstation）分别是WS1，WS2，WS3
<img src=".\picture\image120.png">

+ 每一个工作站运行了一个Frangipani服务
+ 论文中大部分功能都是在Frangipani软件中实现
  + 所以，用户坐在一个工作站前面，他可能在运行一些普通的应用程序，比如说一个普通的文本编辑（VI）或者说一个编译程序（CC）
  + 当这些普通的应用程序执行文件系统调用时，在系统内核中，有一个Frangipani模块，它实现了文件系统
<img src=".\picture\image121.png">

+ 在所有的工作站中，都有类似的结构
<img src=".\picture\image122.png">

+ 文件系统的数据结构
  + 例如文件内容、inode、目录、目录的文件列表、inode和块的空闲状态
  + 所有这些数据都存在一个叫做Petal的共享虚拟磁盘服务中
+ Petal运行在一些不同的服务器上，有可能是机房里面的一些服务器，但是不会是人们桌子上的工作站
  + Petal会复制数据，所以你可以认为Petal服务器成对的出现，这样就算一个故障了，我们还是能取回我们的数据
  + 当Frangipani需要读写文件时，它会向正确的Petal服务器发送RPC
    + 并说，我需要这个块，请读取这个块，并将数据返回给我
  + 在大部分时候，Petal表现的就像是一个磁盘
    + 可以把它看做是共享的磁盘，所有的Frangipani都会与之交互
<img src=".\picture\image123.png">

+ 在Frangipani的设计中
  + Petal作为共享存储系统存在，它不知道文件系统，文件，目录
    + 它只是一个很直观简单的存储系统
    + 所有的复杂的逻辑都在工作站中的Frangipani模块中
  + 所以这是一个非常去中心化的设计
    + 这种设计有好的影响
      + 因为主要的复杂度，主要的CPU运算在每个工作站上
      + 这意味着，随着向系统增加更多的工作站，增加更多的用户
      + 自动的获得了更多的CPU算力来运行这些新的用户的文件系统操作
        + 因为大部分的文件系统操作只在工作站本地发生，所以大部分CPU消耗的都是本地的
        + 所以这个系统的天然自带扩展性
        + 每个新工作站会接收来自一个新用户更多的负担
      + 但是它同时也带来更多的CPU算力来运行那个用户的文件系统操作
+ 瓶颈会在Petal
  + 因为这是一个中心化的存储系统
  + 需要增加更多的存储服务器

<img src=".\picture\image124.png">

+ 所以，现在有了一个系统
  + 它在工作站里面做了大量的缓存，并且文件的修改可以在本地缓存完成
+ 这几乎立刻引出了有关设计的几个非常严重的挑战
# Frangipani的挑战（Challenges）
+ Frangipani的挑战主要来自于两方面
  + 一个是缓存
  + 另一个是这种去中心化的架构带来的大量的逻辑存在于客户端之中进而引起的问题
--------------------------------------------
+ 第一个挑战是，假设工作站W1创建了一个文件 /A
  + 最初，这个文件只会在本地缓存中创建
  + 首先，Frangipani需要从Petal获得 / 目录下的内容
    + 之后当创建文件时，工作站只是修改缓存的拷贝，并不会将修改立即返回给Petal
<img src=".\picture\image126.png">

+ 这里有个直接的问题，假设工作站W2上的用户想要获取 / 目录下的文件列表
  + 我们希望这个用户可以看到新创建的文件
    + 所以这里我们想要非常强的一致性
    + 这样其他人应该能看到这个修改
  + 另一个场景是，如果在一个工作站修改了文件，之后在另一个计算机上编译它
    + 期望编译器能看到我刚刚做的修改
    + 这意味着，文件系统必须要做一些事情来确保客户端可以读到最新的写入文件
    + 在一个缓存的环境中，现在说的一致性的问题不是指存储服务器的一致性，而是指工作站上的一些修改需要被其他工作站看到
      + 因为历史的原因，这通常被称为**缓存一致性（Cache Coherence）**
      + 它表明，如果我缓存了一个数据，并且其他人在他的缓存中修改了这个数据
        + 那么我的缓存需要自动的应用那个修改
------------------------------
+ 另一个问题是
  + 因为所有的文件和目录都是共享的，非常容易会有两个工作站在同一个时间修改同一个目录
  + 假设用户U1在他的工作站W1上想要创建文件/A，这是一个在 / 目录下的新文件
  + 同时，用户U2在他的工作站W2上想要创建文件 /B
<img src=".\picture\image127.png">

+ 他们在同一个目录下创建了不同名字的两个文件A和B
+ 但是他们都需要修改根目录，为根目录增加一个新的文件名
  + 我们不想只创建一个文件
    + 因为第二个文件的创建有可能会覆盖并取代第一个文件
  + 这里期望的行为有很多种叫法，但是这里我们称之为**原子性（Atomicity）**
    + 我们希望类似于创建文件，删除文件这样的操作表现的就像即时生效的一样
    + 同时不会与相同时间其他工作站的操作相互干扰
    + 每一个操作就像在一个时间点发生，而不是一个时间段发生
    + 即使对于复杂的操作，涉及到修改很多状态，我们也希望这些操作表现的好像就是即时生效的
------------------------------
最后一个问题
+ 假设我的工作站修改了大量的内容
  + 由于Write-Back缓存，可能会在本地的缓存中堆积了大量的修改
  + 如果工作站崩溃了，但是这时这些修改只有部分同步到了Petal，还有部分仍然只存在于本地
  + 同时，其他的工作站还在使用文件系统
    + 那么，我的工作站在执行操作的过程中的崩溃,不要损坏其他人同样会使用的文件系统
+ 这意味着，哪怕这些工作站正在查看我的目录，我的文件，它们应该看到一些合理的现象
  + 它们可以漏掉我最后几个操作，但是它们应该看到一个一致的文件系统，而不是一个损坏了的文件系统数据
+ 所以这里我们希望有故障恢复
<img src=".\picture\image128.png">

# Frangipani的锁服务（Lock Server）
+ Frangipani的第一个挑战是缓存一致性
+ Frangipani的缓存一致性核心是由锁保证的
  + 除了Frangipani服务器（也就是工作站），Petal存储服务器
  + 在Frangipani系统中还有第三类服务器，锁服务器
    + 逻辑上，锁服务器是独立的服务器
    + 但是实际上它与Petal服务器运行在一起
+ 在锁服务器里面，有一个表单，就叫做locks
  + 假设每一个锁以文件名来命名
  + 所以对于每一个文件，我们都有一个锁，而这个锁，可能会被某个工作站所持有
<img src=".\picture\image129.png">

+ 在这个例子中，我们假设锁是排他锁（Exclusive Lock）
  + 尽管实际上Frangipani中的锁更加复杂可以支持两种模式：
    + 要么允许一个写入者持有锁，要么允许多个读取者持有锁
+ 假设文件X最近被工作站WS1使用了，所以WS1对于文件X持有锁
  + 同时文件Y最近被工作站WS2使用，所以WS2对于文件Y持有锁
+ 锁服务器会记住每个文件的锁被谁所持有
  + 一个文件的锁也有可能不被任何人持有
<img src=".\picture\image130.png">

+ 在每个工作站，会记录跟踪它所持有的锁，和锁对应的文件内容
  + 所以在每个工作站中，Frangipani模块也会有一个lock表单
    + 表单会记录文件名、对应的锁的状态和文件的缓存内容
    + 这里的文件内容可能是大量的数据块，也可能是目录的列表
+ 当一个Frangipani服务器决定要读取文件
  + 比如读取目录 /、读取文件A、查看一个inode
  + 首先，它会向一个锁服务器请求文件对应的锁
  + 之后才会向Petal服务器请求文件或者目录的数据
  + 收到数据之后，工作站会记住，本地有一个文件X的拷贝，对应的锁的状态，和相应的文件内容
+ 每一个工作站的锁至少有两种模式
  + 工作站可以读或者写相应的文件或者目录的最新数据
  + 可以在创建，删除，重命名文件的过程中
    + 如果这样的话，我们认为锁在Busy状态
<img src=".\picture\image131.png">

+ 在工作站完成了一些操作之后
  + 比如创建文件，或者读取文件
  + 它会随着相应的系统调用（例如rename，write，create，read）释放锁
+ 只要系统调用结束了，工作站会在内部释放锁，现在工作站不再使用那个文件
  + 但是从锁服务器的角度来看，工作站仍然持有锁
    + 工作站内部会标明，这是锁时Idle状态，它不再使用这个锁
  + 所以这个锁仍然被这个工作站持有，但是工作站并不再使用它
<img src=".\picture\image132.png">

+ 现在这里的配置是一致的
  + 锁服务器知道文件X和Y的锁存在，并且都被WS1所持有
+ 工作站WS1也有同等的信息
  + 它内部的表单知道它持有了这两个锁，并且它记住了这两个锁对应的文件或者目录

+ 这里Frangipani应用了很多的规则
  + 这些规则使得Frangipani以一种提供缓存一致性的方式来使用锁
  + 并确保没有工作站会使用缓存中的旧数据
  + 这些规则、锁、缓存数据需要配合使用
+ 这里的规则包括了：

1、工作站不允许持有缓存的数据，除非同时也持有了与数据相关的锁
+ 所以基本上来说，不允许在没有锁保护的前提下缓存数据
+ 从操作意义上来说，这意味着对于一个工作站来说，在它使用一个数据之前
  + 它首先要从锁服务器获取数据的锁
    + 只有当工作站持有锁了，工作站才会从Petal读取数据，并将数据放在缓存中
+ 所以这里的顺序是
  + 获得锁，之后再从Petal读取数据
<img src=".\picture\image133.png">

2、如果你在释放锁之前，修改了锁保护的数据，那你必须将修改了的数据写回到Petal
+ 只有在Petal确认收到了数据，你才可以释放锁，也就是将锁归还给锁服务器
+ 所以这里的顺序是：
  + 先向Petal存储系统写数据，之后再释放锁
  + 最后再从工作站的lock表单中删除关文件的锁的记录和缓存的数据
# 缓存一致性（Cache Coherence）
+ 工作站和锁服务器之间的缓存一致协议协议包含了4种不同的消息
  + 本质上可以认为它们就是一些单向的网络消息
+ 首先是Request消息，从工作站发给锁服务器
  + Request消息会说：hey锁服务器，我想获取这个锁
<img src=".\picture\image134.png">

+ 如果从锁服务器的lock表单中发现锁已经被其他人持有了，那锁服务器不能立即交出锁
+ 但是一旦锁被释放了，锁服务器会回复一个Grant消息给工作站
+ 这里的Request和Grant是异步的
<img src=".\picture\image135.png">

+ 如果向锁服务器请求锁，而另一个工作站现在正持有锁
  + 锁服务器需要持有锁的工作站先释放锁，因为一个锁不能同时被两个人持有
  + 那我们怎么能让这个工作站获取到锁呢？
+ 前面说过，如果一个工作站在使用锁，并在执行读写操作
  + 那么它会将锁标记为Busy
  + 但是通常来说，当工作站使用完锁之后，不会向锁服务器释放锁
+ 所以，如果创建了一个新文件，create函数返回时
  + 这些新文件的锁仍然被我的工作站持有
    + 只是说现在锁的状态会变成Idle而不是Busy
  + 但是从锁服务器看来，我的工作站仍然持有锁
+ 这里延迟将锁还给锁服务器的原因是
  + 如果在工作站上创建了文件Y
  + 接下来几乎肯定要将Y用于其他目的，或许我向它写一些数据，或许会从它读数据
    + 所以，如果工作站能持有所有最近用过的文件的锁并不主动归还的话，会有非常大的优势

+ 所以这里的工作方式是:
  + 如果锁服务器收到了一个加锁的请求
    + 它查看自己的lock表单可以发现
    + 这个锁现在正被工作站WS1所持有
  + 锁服务器会发送一个Revoke消息给当前持有锁的工作站WS1
    + 并说，现在别人要使用这个文件，请释放锁吧
<img src=".\picture\image136.png">

+ 当一个工作站收到了一个Revoke请求
  + 如果锁时在Idle状态，并且缓存的数据脏了
    + 工作站会首先将修改过的缓存写回到Petal存储服务器中
    + 因为前面的规则要求在释放锁之前，要先将数据写入Petal
  + 所以如果锁的状态是Idle
    + 首先需要将修改了的缓存数据发回给Petal
    + 只有在那个时候，工作站才会再向锁服务器发送一条消息说，好吧，我现在放弃这个锁
  + 所以，对于一个Revoke请求的响应是，工作站会向锁服务器发送一条Release消息
<img src=".\picture\image137.png">

+ 如果工作站收到Revoke消息时，它还在使用锁
  + 比如说正在删除或者重命名文件的过程中，直到工作站使用完了锁为止
  + 或者说直到它完成了相应的文件系统操作，它都不会放弃锁
+ 完成了操作之后，工作站中的锁的状态才会从Busy变成Idle
  + 之后工作站才能注意到Revoke请求，在向Petal写完数据之后最终释放锁

+ 就像Petal只是一个块存储服务，并不理解文件系统
  + 锁服务器也不理解文件，目录，还有文件系统
  + 它只是维护lock表单，表单中记录的是锁的名字和锁的持有者
+ Frangipani可以理解锁与某个文件相关联
  + 实际上Frangipani在这里使用的是Unix风格的inode号来作为lock表单的key，而不是文件的名字
-------------------------------------------
如何应用这里的缓存一致协议，并演示Petal操作和和锁服务器操作之间的关联
+ 首先我们有了2个工作站（WS1，WS2），一个锁服务器（LS）
<img src=".\picture\image138.png">

+ 按照协议，如果WS1想要读取并修改文件Z
  + 在它从Petal读取文件之前，它需要先获取对于Z的锁
  + 所以它向锁服务器发送Request消息（下图中ACQ Z）
<img src=".\picture\image139.png">

+ 如果当前没有人持有对文件Z的锁，或者锁服务器没听过对于文件Z的锁（初始化状态）
+ 锁服务器会在lock表单中增加一条记录，并返回Grant消息给工作站说，你现在持有了对于Z文件的锁
<img src=".\picture\image140.png">

+ 从这个时间点开始，工作站WS1持有了对文件Z的锁，并且被授权可以从Petal读取Z的数据
+ 所以这个时间点，WS1会从Petal读取并缓存Z的内容
+ 之后，WS1也可以在本地缓存中修改Z的内容
<img src=".\picture\image141.png">

+ 过了一会，坐在工作站WS2前面的用户也想读取文件Z
  + 但是一开始WS2并没有对于文件Z的锁
  + 所以它要做的第一件事情就是向锁服务器发送Request消息，请求对于文件Z的锁
<img src=".\picture\image142.png">

+ 但是，锁服务器知道不能给WS2回复Grant消息，因为WS1现在还持有锁
  + 接下来锁服务器会向WS1发送Revoke消息
<img src=".\picture\image143.png">

+ 而工作站WS1在向Petal写入修改数据之前，不允许释放锁
  + 所以它现在会将任何修改的内容写回给Petal
<img src=".\picture\image144.png">

+ 写入结束之后，WS1才可以向锁服务器发送Release消息
<img src=".\picture\image145.png">

+ 锁服务器必然会有一个表单记录谁在等待文件Z的锁
  + 一旦锁的当前持有者释放了锁，锁服务器需要通知等待者
  + 所以当锁服务器收到了这条Release消息时，锁服务器会更新自己的表单，并最终将Grant消息发送给工作站WS2
<img src=".\picture\image146.png">

+ 这个时候，WS2终于可以从Petal读取文件Z
<img src=".\picture\image147.png">

+ 这就是缓存一致性协议的工作流程
+ 它确保了，直到所有有可能私底下在缓存中修改了数据的工作站先将数据写回到Petal
  + 其他工作站才能读取相应的文件
  + 所以，这里的锁机制确保了读文件总是能看到最新写入文件的数据。 
-------------------------------
+ Frangipani有共享的读锁（Shared Read Lock）和排他的写锁（Exclusive Write Lock）
  + 如果有大量的工作站需要读取文件，但是没有人会修改这个文件
  + 它们都可以同时持有对这个文件的读锁
+ 如果某个工作站需要修改这个已经被大量工作站缓存的文件时
  + 那么它首先需要Revoke所有工作站的读锁
    + 这样所有的工作站都会放弃自己对于该文件的缓存
    + 只有在那时，这个工作站才可以修改文件
      + 因为没有人持有了这个文件的缓存，所以就算文件被修改了，也没有人会读到旧的数据
# 原子性（Atomicity）
下一个挑战是确保原子性
+ 当做了一个复杂的操作
  + 比如说创建一个文件
    + 这里涉及到:
      + 标识一个新的inode
      + 初始化一个inode（inode是用来描述文件的一小份数据）
      + 为文件分配空间
      + 在目录中为新文件增加一个新的名字
    + 这里有很多步骤，很多数据都需要更新
      + 我们不想任何人看到任何中间的状态
      + 所以我们希望多个步骤的操作具备原子性
+ 为了实现原子性，为了让多步骤的操作
  + 例如创建文件，重命名文件，删除文件具备原子性
  + Frangipani在内部实现了一个数据库风格的事务系统，并且是以锁为核心
--------------------------------------------
+ 简单来说，Frangipani是这样实现分布式事务的：
  + 在完全完成操作之前，Frangipani确保其他的工作站看不到我的修改
  + 首先工作站需要获取所有我需要读写数据的锁
    + 在完成操作之前，我的工作站不会释放任何一个锁
    + 并且为了遵循一致性规则，将所有修改了的数据写回到Petal之后，我的工作站才会释放所有的锁
      + 比如将文件从一个目录移到另一个目录，这涉及到修改两个目录的内容
      + 我不想让人看到两个目录都没有文件的状态
      + 为了实现这样的结果，Frangipani首先会获取执行操作所需要的所有数据的锁，
<img src=".\picture\image148.png">

+ 之后完成所有的步骤，比如完成所有数据的更新，并将更新写入到Petal，最后释放锁
<img src=".\picture\image149.png">

+ 因为我们有了锁服务器和缓存一致性协议
  + 我们只需要确保我们在整个操作的过程中持有所有的锁，我们就可以无成本的获得这里的不可分割原子事务

+ 所以为了让操作具备原子性，Frangipani持有了所有的锁
  + 对于锁来说，这里有一件有意思的事情，Frangipani使用锁实现了两个几乎相反的目标
    + 对于缓存一致性
      + Frangipani使用锁来确保写操作的结果对于任何读操作都是立即可见的
      + 所以对于缓存一致性，这里使用锁来确保写操作可以被看见
    + 但是对于原子性来说
      + 锁确保了人们在操作完成之前看不到任何写操作，因为在所有的写操作完成之前，工作站持有所有的锁
#  Frangipani Log
下一个有意思的事情是故障恢复
+ 我们需要能正确应对这种场景：
  + 一个工作站持有锁，并且在一个复杂操作的过程中崩溃了
  + 比如说一个工作站在创建文件，或者删除文件时，它首先获取了大量了锁，然后会更新大量的数据
  + 这时工作站崩溃了，并且锁也没有释放（因为数据回写还没有完成）
+ 我们绝对需要释放锁
  + 这样其他的工作站才能使用这个系统，使用相同的文件和目录
  + 但同时，我们也需要处理这种场景：
    + 崩溃了的工作站只写入了与操作相关的部分数据，而不是全部的数据
+ Frangipani与其他的系统一样，需要通过预写式日志（Write-Ahead Log，WAL）
  + 实现故障可恢复的事务（Crash Recoverable Transaction）
<img src=".\picture\image150.png">

+ 当一个工作站需要完成涉及到多个数据的复杂操作时
  + 在工作站向Petal写入任何数据之前，工作站会在Petal中自己的Log列表中追加一个Log条目
  + 这个Log条目会描述整个的需要完成的操作
  + 只有当这个描述了完整操作的Log条目安全的存在于Petal之后，工作站才会开始向Petal发送数据
  + 所以如果工作站可以向Petal写入哪怕是一个数据
    + 那么描述了整个操作、整个更新的Log条目必然已经存在于Petal中
+ 这是一种非常标准的行为，它就是WAL的行为
  + 但是Frangipani在实现WAL时，有一些不同的地方:
    + 第一个是，在大部分的事务系统中，只有一个Log，系统中的所有事务都存在于这个Log中
      + 当有故障时，如果有多个操作会影响同一份数据
      + 我们在这一个Log里，就会保存这份数据的所有相关的操作
      + 所以我们知道，对于一份数据，哪一个操作是最新的
    + 但是Frangipani不是这么保存Log的，它对于每个工作站都保存了一份独立的Log
<img src=".\picture\image151.png">

+ 另一个有关Frangipani的Log系统有意思的事情是:
  + 工作站的Log存储在Petal，而不是本地磁盘中
    + 几乎在所有使用了Log的系统中，Log与运行了事务的计算机紧紧关联在一起，总是保存在本地磁盘中
  + 但是出于优化系统设计的目的，Frangipani的工作站将自己的Log保存在作为共享存储的Petal中
    + 每个工作站都拥有自己的半私有的Log，但是却存在Petal存储服务器中
    + 这样的话，如果工作站崩溃了，它的Log可以被其他工作站从Petal中获取到
    + 所以Log存在于Petal中
<img src=".\picture\image152.png">

+ 这里其实就是，每个工作站的独立的Log，存放在公共的共享存储中

+ 论文说了每个工作站的Log存在于Petal已知的块中
  + 并且，每个工作站以一种环形的方式使用它在Petal上的Log空间
  + Log从存储的起始位置开始写，当到达结尾时，工作站会回到最开始，并且重用最开始的Log空间
  + 所以工作站需要能够清除它的Log，这样就可以确保，在空间被重复利用之前，空间上的Log条目不再被需要
+ 每个Log条目都包含了Log序列号，这个序列号是个自增的数字
  + 每个工作站按照12345为自己的Log编号
  + 如果工作站崩溃了，Frangipani会探测工作站Log的结尾
    + Frangipani会扫描位于Petal的Log直到Log序列号不再增加
    + 这个时候Frangipani可以确定最后一个Log必然是拥有最高序列号的Log
    + 所以Log条目带有序列号是因为Frangipani需要检测Log的结尾
<img src=".\picture\image153.png">

+ 除此之外，每个Log条目还有一个用来描述一个特定操作中所涉及到的所有数据修改的数组
  + 数组中的每一个元素会有一个Petal中的块号（Block Number），一个版本号和写入的数据
  + 类似的数组元素会有多个，这样就可以用来描述涉及到修改多份文件系统数据的操作
<img src=".\picture\image154.png">

+ 这里有一件事情需要注意，Log只包含了对于元数据的修改
  + 比如说文件系统中的目录、inode、bitmap的分配
  + Log本身不会包含需要写入文件的数据
  + 所以它并不包含用户的数据，它只包含了故障之后可以用来恢复文件系统结构的必要信息
    + 例如，在一个目录中创建了一个文件F，那会生成一个新的Log条目
    + 里面的数组包含了两个修改的描述
      + 一个描述了如何初始化新文件的inode
      + 另一个描述了在目录中添加的新文件的名字
<img src=".\picture\image155.png">

+ 为了能够让操作尽快的完成
  + 最初的时候，Frangipani工作站的Log只会存在工作站的内存中
  + 并尽可能晚的写到Petal中
    + 这是因为，向Petal写任何数据，包括Log，都需要花费较长的时间
    + 所以我们要尽可能避免向Petal写入Log条目，就像我们要尽可能避免向Petal写入缓存数据一样

+ 所以，这里的完整的过程是
+ 当工作站从锁服务器收到了一个Revoke消息，要自己释放某个锁，它需要执行好几个步骤
  + 首先，工作站需要将内存中还没有写入到Petal的Log条目写入到Petal中
  + 之后，再将被Revoke的Lock所保护的数据写入到Petal
  + 最后，向锁服务器发送Release消息

# 故障恢复（Crash Recovery）
当工作站持有锁，并且故障了会发生什么。

+ 这里的场景是
  + 当工作站需要重命名文件或者创建一个文件时
  + 首先它会获得所有需要修改数据的锁，之后修改自身的缓存来体现改动
  + 但是后来工作站在向Petal写入数据的过程中故障了
  + 工作站可能在很多个位置发生故障
    + 但是由于前面介绍过的工作流程，Frangipani总是会先将自身的Log先写入到Petal
    + 这意味着如果发生了故障，那么发生故障时可能会有这几种场景：
      + 要么工作站正在向Petal写入Log，所以这个时候工作站必然还没有向Petal写入任何文件或者目录
      + 要么工作站正在向Petal写入修改的文件，所以这个时候工作站必然已经写入了完整的Log

+ 当持有锁的工作站崩溃了之后，发生的第一件事情是锁服务器向工作站发送一个Revoke消息
  + 但是锁服务器得不到任何响应，之后才会触发故障恢复
    + 如果没有人需要用到崩溃工作站持有的锁，那么基本上没有人会注意到工作站崩溃了
  + 假设一个其他的工作站需要崩溃了的工作站所持有的一个锁
    + 锁服务器会发出Revoke消息，但是锁服务器永远也不会从崩溃了的工作站收到Release消息
    + Frangipani出于一些原因对锁使用了租约
      + 当租约到期了，锁服务器会认定工作站已经崩溃了，之后它会初始化恢复过程
    + 实际上，锁服务器会通知另一个还活着的工作站说：
      + 看，工作站1看起来崩溃了
      + 请读取它的Log，重新执行它最近的操作并确保这些操作完成了
      + 在你完成之后通知我
    + 在收到这里的通知之后，锁服务器才会释放锁
    + 这就是为什么日志存放在Petal是至关重要的
      + 因为一个其他的工作站可能会要读取这个工作站在Petal中的日志
<img src=".\picture\image156.png">

-----------------------------------
发生故障的场景究竟有哪些呢？
+ 第一种场景是，工作站WS1在向Petal写入任何信息之前就故障了
  + 这意味着，当其他工作站WS2执行恢复，查看崩溃了的工作站的Log时，发现里面没有任何信息
    + 自然也就不会做任何操作
  + 之后WS2会释放WS1所持有的锁
  + 工作站WS1或许在自己的缓存中修改了各种各样的数据
    + 但是如果它没有在自己的Log存储区写入任何信息
    + 那么它也不可能在Petal中写入任何它修改的块数据
  + 我们会丢失WS1的最后几个操作，但是文件系统会与WS1开始修改之前保持一致
    + 因为很明显，工作站WS1没能走到向Petal写Log那一步，自然也不可能向Petal写入块数据
+ 第二种场景是，工作站WS1向Petal写了部分Log条目
  + 这样的话，执行恢复的工作站WS2会从Log的最开始向后扫描，直到Log的序列号不再增加
    + 因为这必然是Log结束的位置
  + 工作站WS2会检查Log条目的更新内容，并向Petal执行Log条目中的更新内容
  + 比如Petal中的特定块需要写入特定的数据，这里对应的其实就是工作站WS1在自己本地缓存中做的一些修改
  + 所以执行恢复的工作站WS2会检查每个Log条目
    + 并重新向Petal执行WS1的每一条Log
    + 当WS2执行完WS1存放在Petal中的Log，它会通知锁服务器，之后锁服务器会释放WS1持有的锁
    + 这样的过程会使得Petal更新至故障工作站WS1在故障前的执行的部分操作
      + 或许不能全部恢复WS1的操作
      + 因为故障工作站可能只向Petal写了部分Log就崩溃了
    + 同时，除非在Petal中找到了完整的Log条目，否则执行恢复的工作站WS2是不会执行这条Log条目的
      + 所以，这里的隐含意思是需要有类似校验和的机制，这样执行恢复的工作站就可以知道
+ 另一个有趣的可能是，工作站WS1在写入Log之后，并且在写入块数据的过程中崩溃了
  + 先不考虑一些极其重要的细节，执行恢复的工作站WS2并不知道WS1在哪个位置崩溃的
    + 它只能看到一些Log条目
  + 同样的，WS2会以相同的方式重新执行Log
  + 尽管部分修改已经写入了Petal，WS2会重新执行修改
    + 对于部分已经写入的数据，相当于在相同的位置写入相同的数据
    + 对于部分未写入的数据，相当于更新了Petal中的这部分数据，并完成了操作
------------------------------------
+ 下面的这个场景会更加复杂一些
  + 如果一个工作站，完成了上面流程的步骤1，2，在释放锁的过程中崩溃了
  + 进而导致崩溃的工作站不是最后修改特定数据的工作站
+ 具体可以看下面这个例子
  + 假设我们有一个工作站WS1，它执行了删除文件（d/f）的操作
<img src=".\picture\image157.png">

+ 之后，有另一个工作站WS2，在删除文件之后，以相同的名字创建了文件
  + 这是一个不同的文件
+ 所以之后，工作站WS2创建了同名的文件（d/f）
+ 在创建完成之后，工作站WS1崩溃了
<img src=".\picture\image158.png">

+ 所以，我们需要基于WS1的Log执行恢复
+ 这时，可能有第三个工作站WS3来执行恢复的过程
<img src=".\picture\image159.png">

+ 这里的时序表明，WS1删除了一个文件，WS2创建了一个文件，WS3做了恢复操作
+ 有可能删除操作仍然在WS1的Log中
  + 当WS1崩溃后，WS3需要读取WS1的Log，并重新执行WS1的Log中的更新
  + 因为删除文件的Log条目仍然存在于WS1的Log中，如果不做任何额外的事情，WS3会删除这个文件（d/f）
  + 但是实际上，WS3删除的会是WS2稍后创建的一个完全不同的文件
+ 这样的结果是完全错误的
  + 因为需要被删除的是WS1指定的文件，而不是WS2创建的一个相同名字的文件


+ Frangipani是这样解决这个问题的:
  + **对每一份存储在Petal文件系统数据增加一个版本号**
  + 同时将版本号与Log中描述的更新关联起来
  + 在Petal中，每一个元数据，每一个inode，每一个目录下的内容，都有一个版本号
+ 当工作站需要修改Petal中的元数据时
  + 它会向从Petal中读取元数据，并查看当前的版本号
  + 之后在创建Log条目来描述更新时，它会在Log条目中对应的版本号填入元数据已有的版本号加1
<img src=".\picture\image160.png">

+ 之后，如果工作站执行到了写数据到Petal的步骤，它也会将新的增加了的版本号写回到Petal
+ 所以，如果一个工作站没有故障，并且成功的将数据写回到了Petal
  + 这样元数据的版本号会大于等于Log条目中的版本号
  + 如果有其他的工作站之后修改了同一份元数据，版本号会更高
+ 所以，实际上WS3看到的WS1的删除操作对应的Log条目，会有一个特定的版本号
  + 它表明，由这个Log条目影响的元数据对应版本号3（举例）
<img src=".\picture\image161.png">

+ WS2的修改在WS1崩溃之前，所以WS1必然已经释放了相关数据的锁
  + WS2获得了锁，它会读取当前的元数据可以发现当前的版本号是3
  + 当WS2写入数据的时候，它会将版本号设置为4
<img src=".\picture\image162.png">

+ 之后，当WS3执行恢复流程时，WS3会重新执行WS1的Log
  + 它会首先检查版本号，通过查看Log条目中的版本号
  + 并查看Petal中存储的版本号
    + 如果Petal中存储的版本号大于等于Log条目中的版本号
    + 那么WS3会忽略Log条目中的修改
      + 因为很明显Petal中的数据已经被故障了的工作站所更新
      + 甚至可能被后续的其他工作站修改了
    + 所以在恢复的过程中，WS3会选择性的根据版本号执行Log
      + **只有Log中的版本号高于Petal中存储的数据的版本时，Log才会被执行**
